% Вобщем мне надо написать функции нахождения максимального и 
% минимального собственных чисел матрицы степенным и градиентным методом. 
% Максимальное собственное число степенным методом я нашел: 
% 
function [lambda,X,k]=eig_powermax(A,epsilon,max_k)
% Вход     - A - матрица n x n
%          - epsilon - допустимая погрешность
%          - max_k - максимальное число итераций
% Выход    - lambda - максимальное по модулю собственное значение
%          - X - соответствующий собственный вектор

% инициализация параметров

k=0; % номер итерации
[m,n]=size(A); % размерность матрицы
if m~=n
    error('Матрица не квадратная')
end

X=ones(n,1); % единичное начальное приближение

while 1 
    k=k+1;% счетчик итераций
    if k>max_k
       error('Число итераций больше заданного')
    end
    Y=A*X;
    if k>=2
        lambda_s=lambda;
    end
    lambda=(Y'*X)/(X'*X);
    % нормализация Y
    X=(1/norm(Y,inf))*Y;
    % проверка условия окончания
    if k>=2
        if abs(lambda-lambda_s)/abs(lambda)<=epsilon
            break
        end
    end
end % конец цикла
return


% А минимальное не получается....как я понял там надо решить систему 
% A*Y^(k+1)=X^(k), после чего получится максимальное собственное число 
% м-цы A^-1, а его обратное значение будет минимальным у м-цы A. Я пишу:
function [lambda,X,k]=eig_powermin(A,epsilon,max_k)
% Вход     - A - матрица n x n
%          - epsilon - допустимая погрешность
%          - max_k - максимальное число итераций
% Выход    - lambda - минимальное по модулю собственное значение
%          - X - соответствующий собственный вектор

% инициализация параметров

k=0; % номер итерации
[m,n]=size(A); % размерность матрицы
if m~=n
    error('Матрица не квадратная')
end

X=ones(n,1); % единичное начальное приближение

while 1 
    k=k+1;% счетчик итераций
    if k>max_k
       error('Число итераций больше заданного')
    end
    Y=X/A;
    if k>=2
        lambda_s=lambda;
    end
    lambda=(Y'*X)/(X'*X);
    % нормализация Y
    X=(1/norm(Y,inf))*Y;
    % проверка условия окончания
    if k>=2
        if abs(lambda-lambda_s)/abs(lambda)<=epsilon
            break
        end
    end
end % конец цикла
lambda=1/lambda;
return
